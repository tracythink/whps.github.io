/*
** 以上代表了观点，仅供参考
** 不过我还是认为大部分是可用的
*/
#logdate 14.9.8
Q
有非常丰富的 Linux/Unix 下工作的经验指的是什么？
A
丰富经验：
0. 了解FHS（Filesystem Hierarchy Standard）;
1. 了解Bash/Shell工作原理;
2. 能用Bash/Shell结合AWK/Sed及其它小型实用程序，完成日常工作;
3. 了解守护进程和服务的启停（含启停脚本编写）;
4. 了解系统默认使用的软件包管理工具，能按照要求安装软件包;
5. 了解如何在Shell中进行内核微调;
6. 了解如何挂载、管理外部设备;
7. 了解如何管理用户及权限;
8. 了解一款全屏文本编辑器的使用（VI / VIM / Emacs）。

非常丰富经验：
0. 理解FHS的郁闷之处;
1. 理解Bash/Shell的缺陷，知道如何高效编写而不落入致命陷阱;
2. 熟知每种小型实用程序（含Shell）的典型应用场景、技巧;
3. 能用Perl、Python、Ruby、C等进行扩展程序开发;
4. 能手动安装各种软件包（含下载、展开、编译、安装、测试）;
5. 理解设备工作原理，能做故障排查;
6. 理解系统安全特性，适时打补丁;
7. 能独立编译内核;
8. 熟练微调内核;
9. 熟练使用一款全屏文本编辑器;
10. 理解网络工作原理，并能配置调优网络（如防火墙等）。

强力补充：
0. 能构建交叉编译环境;
1. 玩Perl跟玩大刀似的;
2. 或者熟练使用随便哪种快速编程语言。
#endlogdate

#logdate 14.9.7
Q
how to say 'i love you to a gril' ?
A
99669999996669999996699666699666999966699666699
99699999999699999999699666699669966996699666699
99669999999999999996699666699699666699699666699
99666699999999999966666999966699666699699666699
99666666999999996666666699666699666699699666699
99666666669999666666666699666669966996699666699
99666666666996666666666699666666999966669999996
(key:9,you can also replace some special char)
Q
what is fuck callback function
A
你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，
过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。
在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，
店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。
Q
算法怎么学
A
先理解时间和空间复杂度的计算，然后把你的语言的容器和算法（譬如说C++就是各种容器和<algorithm>）的复杂度背下来，
然后找出你用了他们的很多代码，不断地练习计算复杂度，然后通过测量时间的方法，拟合复杂度曲线来看看你算的是不是对的。
等你对这些东西有了感觉之后（对于某些天才来说不需要这么做，看一下复杂度的概念做几道题就建立起感觉了），
你再去看算法的具体实现，事半功倍。
Q
用什么工具，系统，语言，研究方向，etc
A
最终让你自己自身价值发扬光大的，是你的领域知识，而不是工具。
哪个顺手用哪个。或者实在不知情 FIFO吧。
靠谱的程序员，从来都是因为写出来的代码靠谱而让自己变得靠谱。二逼的程序员，从来都是通过宣传自己的工具……

#What
搞GUI的东西有一个很简单的鉴定方法。如果官方的GUI拖控件程序是用自己的前一个版本开发自己的后一个版本的，那就可以用。
#endWhat

Q
如何快速的学习一门编程语言
A
1. 首先了解该语言的基本数据类型，基本语法和主要语言构造
2. 其次掌握数组和其他集合类的使用
3. 简单字符串处理。所谓简单，就是Regex和Parser以下的内容，什么查找替换，截断去字串之类的
4. 基本面向对象或者函数式编程的特征<whps>(可略)
5. 异常、错误处理、断言、日志和调试支持，对单元测试的支持
6. 程序代码和可执行代码的组织机制，运行时模块加载、符号查找机制
7. 基本输入输出和文件处理，输入输出流类的组织
8. 该语言如何进行callback方法调用，如何支持事件驱动编程模型
9. 如果有必要，可在这时研究regex和XML处理问题，如无必要可跳过
10. 序列化和反序列化，掌握一下缺省的机制就可以了
11. 如果必要，可了解一下线程、并发和异步调用机制，主要是为了读懂别人的代码，
    如果自己要写这类代码，必须专门花时间严肃认真系统地学习，严禁半桶水上阵
12. 动态编程，反射和元数据编程，数据和程序之间的相互转化机制，运行时编译和执行的机制，
    有抱负的开发者在这块可以多下些功夫，能够使你对语言的认识高出一个层面
13. 如果有必要，可研究一下该语言对于泛型的支持，不必花太多时间，只要能使用现成的泛型集合和泛型函数就可以了，
    可在以后闲暇时抽时间系统学习。
    需要注意的是，泛型技术跟多线程技术一样，用不好就成为万恶之源，必须系统学习，谨慎使用，否则不如不学不用
14. 如果还有时间，最好咨询一下有经验的人，看看这个语言较常用的特色features是什么，如果之前没学过，应当补一下。
15. 有必要的话，在工作的闲暇时间，可以着重考察两个问题，第一，这个语言有哪些惯用法和模式，
    第二，这个语言的编译/解释执行机制
16. <whps>(学完编译应该能对语法有个好个理解，代码量要积累)
#endlogdate

#logdate 14.9.12
Q
你有什么技能或知识是可以跨领域迁移的
A
遇到麻烦保持理智
#endlogdate
